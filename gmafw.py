"""
Analysis utilities for polarization sensivity simulations
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.optimize import curve_fit
from inspect import signature
import gzip
import h5py
import subprocess

from trafile import MDP, parFile, namelistFromPar,  LoadingBar

__author__ = "Adrien Laviron"
__version__ = "alpha"

def decra2tpPA(dec, ra, s, unit="deg"):
  """
  Converts dec,ra (declination, right ascension) world coordinates into satellite attitude parameters
  Polarization angle calculation rely on the fact that the polarization angle in is the plane generated by the direction of the source and the dec=0 direction, as it is the case in mamr.py. 
  :param dec: declination (except it is 0 at north pole, 90° at equator and 180° at south pole)
  :param ra : Right ascension (0->360°)
  :param s: satellite from infos['satellites']
  :param unit: unit in which are given dec and ra, default="deg"
  :returns: theta_sat, phi_sat, polarization angle in deg with MEGAlib's RelativeY convention
  """
  if unit=='deg':
    dec, ra = np.deg2rad(dec), np.deg2rad(ra)
  theta = np.arccos( np.product(np.sin(np.array([dec, ra, s[0], s[1]]))) + np.sin(dec)*np.cos(ra)*np.sin(s[0])*np.cos(s[1]) + np.cos(dec)*np.cos(s[0]) )
  source = [np.sin(dec)*np.cos(ra), np.sin(dec)*np.sin(ra), np.cos(dec)]
  yprime = [-np.cos(s[0])*np.cos(s[1]), -np.cos(s[0])*np.sin(s[1]), np.sin(s[0])]
  xprime = [-np.sin(s[1]), np.cos(s[1]), 0]
  phi = np.mod(np.arctan2(np.dot(source, yprime), np.dot(source, xprime)), 2*np.pi)
  # Polarization
  dec_p, ra_p = np.mod(.5*np.pi-dec, np.pi), ra+np.pi #polarization direction in world coordinates (towards north or south pole)
  vecpol = [np.sin(dec_p)*np.cos(ra_p), np.sin(dec_p)*np.sin(ra_p), np.cos(dec_p)] #polarization vector in world coordinates
  return np.rad2deg(theta), np.rad2deg(phi), np.rad2deg(np.arccos( np.dot(vecpol, np.cross(source, yprime)) ))


def angle(c, theta, phi):
  """
  Calculate the azimuthal Compton angle
  :param c:     3-uple, Compton scattered gamma-ray vector
  :param theta: float,  source polar angle in sky in rad
  :param phi:   float,  source azimuthal angle in sky in rad
  :returns:     float,  angle in deg
  """
  # Pluging in some MEGAlib magic
  c = (np.cos(-phi)*c[0] - np.sin(-phi)*c[1], np.sin(-phi)*c[0] + np.cos(-phi)*c[1], c[2])
  c = (np.sin(-theta)*c[2] + np.cos(-theta)*c[0], c[1], np.cos(-theta)*c[2] - np.sin(-theta)*c[0])
  # Figure out a good arctan
  if c[0] > 0:
    return np.arctan(c[1]/c[0])*180/np.pi
  elif c[0] == 0:
     return 90
  else:
     if c[1] > 0:
       return np.arctan(c[1]/c[0])*180/np.pi+180
     else:
       return np.arctan(c[1]/c[0])*180/np.pi-180

def inwindow(E, ergCut):
  """
  Checks whether E is in the energy window defined by ergCut
  :param E: energy
  :param ergCut: (Emin, Emax)
  :returns: bool
  """
  return E > ergCut[0] and E < ergCut[1]

def readevt(fname, ergCut=None):
  """
  Reads a .tra or .tra.gz file and returns the Compton scattered gamma-ray vector
  :param fname: str, name of .tra file
  :param ergCut: couple (Emin, Emax) or None, energy range in which events have to be to be processed, default=None(=no selection)
  :returns:     list of 3-uple of float
  """
  if fname.endswith(".tra"):
    with open(fname) as f:
      data = f.read().split("SE")[1:]
  elif fname.endswith(".tra.gz"):
    with gzip.open(fname, "rt") as f:
      data = "".join(f).split("SE")[1:]
#      data = [e[:-1] for e in f] per line readout
  else:
    raise TypeError("{} has unknown extension (known: .tra ou .tra.gz)".format(fname))
#  with open(fname) as f:
#    data=f.read().split("SE")[1:]
  ret = []
  if ergCut is None:
    for evt in data:
      if "ET CO" in evt:
        for line in evt.split("\n"):
          if line.startswith("CD"):
            dat = list(map(float, line.replace("   "," ").split(" ")[1:]))
            ret.append((dat[6]-dat[0], dat[7]-dat[1], dat[8]-dat[2]))
  else:
    for evt in data:
      if "ET CO" in evt:
        lines = evt.split("\n")
        for i, line in enumerate(lines):
          if line.startswith("CE"):
            E = [float(e) for e in line.replace("   "," ").split(" ")[1:]]
            if inwindow(E[0]+E[2], ergCut):
              dat = list(map(float, lines[i+1].replace("   "," ").split(" ")[1:]))
              ret.append((dat[6]-dat[0], dat[7]-dat[1], dat[8]-dat[2]))
  return ret

def anglecor(theta, phi, PA):
  """
  Multi-satellite correction angle
  """
  return np.rad2deg(np.arctan(np.cos(theta)*np.tan(phi))+PA)

def analyzetra(fname, theta=0, phi=0, PA=0, corr=False, ergCut=None):
  """
  Reads a .tra file and returns the azimuthal angles used in polarigrams (corrected from the source sky position and from cosima's "RelativeY" polarization definition)
  :param fname: str,   name of file to read from
  :param tetha: float, polar angle of source in sky in rad, default=0
  :param phi:   float, azimuthal angle of source in sky in rad, default=0
  :param PA:    float, polarization angle in source file in rad, default=0
  :param corr:  bool,  wether to correct for the source sky position and cosima's "RelativeY" polarization definition or not, default=False
  :param ergCut: couple (Emin,Emax) or None, energy range in which to perform polarization analysis, default=None (no selection)
  :returns:     list of float, azimuthal angles of Compton scattered gamma-rays
  """
  data = readevt(fname, ergCut)
  angles = []
  if corr:
    for evt in data:
      #angles.append(angle(evt, theta, phi)+np.arctan(np.cos(theta)*np.tan(phi))+PA)
      angles.append(angle(evt, theta, phi)+np.rad2deg(np.arctan(np.cos(theta)*np.tan(phi))+PA))
  else:
    for evt in data:
      angles.append(angle(evt, theta, phi))
  return angles

def polar(angles, bins=np.arange(-180, 181, 18)):
  """
  Generates polarigram out of a list of angles
  :param angles: list of float, angles
  :param bins:   list of float, bins of the polarigram, default= 10 bins between -180° and 180°
  :returns:      np.array,      polarigram
  """
  return np.histogram(angles, bins)[0]

def plot3d(data, extent=None, width=None, depth=None, bottom=None, epsilon=.01, **kwargs):
  """
  Plots 2D data in 3D bars
  :param data:    2D np.array,       data
  :param extent:  tuple,             min and max for all three axes,   default=max of data
  :param width:   float or np.array, width of bars,                    default=no space between bars
  :param depth:   float or np.array, depth of bars,                    default=no space between bars
  :param bottom:  float or np.array, coordinate of the bottom of bars, default=0
  :param epsilon: float,             value >0 small compared to data,  default=.01
  :kwarg xlabel:  str,               label of x axis,                  default=None
  :kwarg ylabel:  str,               label of y axis,                  default=None
  :kwarg zlabel:  str,               label of z axis,                  default=None
  """
  if extent is None:
    extent = (0, data.shape[1], 0, data.shape[0], 0, np.max(data))
  if width is None:
    width = (extent[1]-extent[0])/data.shape[1] -epsilon
  if depth is None:
    depth = (extent[3]-extent[2])/data.shape[0] -epsilon
  if bottom is None:
    bottom = np.full_like(data.flatten(), extent[4])
  _x = np.arange(extent[0], extent[1]+epsilon, (extent[1]-extent[0]) / (data.shape[1]-1))
  _y = np.arange(extent[2], extent[3]+epsilon, (extent[3]-extent[2]) / (data.shape[0]-1))
  _xx, _yy = np.meshgrid(_x, _y)
  x, y = _xx.ravel(), _yy.ravel()
  fig = plt.figure()
  ax = plt.axes(projection="3d")
  ax.bar3d(x, y, bottom, width, depth, np.fmin(data.flatten(), extent[5]))
  ax.set_xlabel(kwargs.get("xlabel", None))
  ax.set_ylabel(kwargs.get("ylabel", None))
  ax.set_zlabel(kwargs.get("zlabel", None))
  plt.show()

def func(x, pa, mu, S):
  """
  Polarigram model
  :param x:  float or np.array, azimutal compt angle
  :param pa: float,             polarization angle
  :param mu: float,             contrast of polarization signal
  :param S:  float,             source flux
  :returns:  float or np.array
  """
  return ( S / (2*np.pi) ) * ( 1- mu*np.cos( np.pi*(x - pa)/90 ))


class Fit:
  """
  Fit container
  :field f:       function, function fitted to data
  :field x:       np.array, data parameter
  :field y:       np.array, data
  :field popt:    np.array, optimum parameters
  :field pcov:    np.array, covariance matrix
  :field comment: str,      comment on the fit (ex: type, human readable name of function, ...)
  :field q2:      float,    Q^2 value of the fit
  :field nparam:  int,      number of parameters of the function
  """

  def __init__(self, f, x, y, comment=""):
    """
    Instanciates a Fit
    :param f:       function, function fitted to data
    :param x:       np.array, data parameter
    :param y:       np.array, data
    :param comment: str,      comment on the fit (ex: type, human readable name of function, ...)
    :returns:       Correctly instanciated Fit
    """
    self.f = f
    self.x = x
    self.y = y
    self.popt, self.pcov = curve_fit(f, x, y)
    self.comment = comment
    yf = f(x, *self.popt)
    self.q2 = np.sum( ( y - yf ) **2)
    self.nparam = len(signature(f).parameters)-1

  def show(self):
    """
    """
    pass

  def disp(self):
    """
    Some statistical magic happens here
    """
    if self.comment == "modulation":
      print("\nPolarization analysis:")
      pa = (self.popt[0] + (90 if self.popt[1] <0 else 0)) % 180
      print("\tModulation        :  {}+-{}".format(abs(self.popt[1]), np.sqrt(self.pcov[1][1])))
      print("\tPolarization angle: ({}+-{}) deg".format(pa, np.sqrt(self.pcov[0][0])))
      print("\tSource flux       :  {}+-{}".format(self.popt[2], np.sqrt(self.pcov[2][2])))
      print("\tFit goodness      : {}\n".format(self.q2/(len(self.x)-self.nparam)))
    elif self.comment == "constant":
      print("\nConstant fit:")
      print("\tFit goodness      : {}\n".format(self.q2/(len(self.x)-self.nparam)))
    else:
      print("\n{}: Unknown fit type - displaying raw results".format(self.comment))
      print(self.popt)
      print(np.sqrt(np.diag(self.pcov)))
      print(self.pcov)
      print("Q^2 / ndof: {}\n".format(self.q2/(len(self.x)-self.nparam)))


class Polarigram(list):
  """
  Polarigram is a container for usual data regarding polarization measurements and usefull functions for data analysis
  :self: Heritates from list, list of angles in deg
  :field bins:  iterable, bins with which histograms are calculated in deg
  :field theta: float,    source position's polar angle theta in rad
  :field phi:   float,    source position's azimuthal angle theta in rad
  :field PA:    float,    polarization angle of the source as defined in cosima's source file for "RelativeY" polarization definition in deg
  :field fits:  list,     list of Fit instances applied to the Polarigram
  """
  
  def __init__(self, data, theta, phi, PA, bins=np.arange(-180, 181, 18), corr=False, ergCut=None):
    """
    Correctly instanciates a Polarigram, filled with data
    :param data:  list or str, list of angles in deg or name of .tra file
    :param theta: float,       source position's polar angle theta in deg (will be converted to rad)
    :param phi:   float,       source position's azimuthal angle theta in deg (will be converted to rad)
    :param PA:    float,       polarization angle of the source as defined in cosima's source file for "RelativeY" polarization definition in deg
    :param bins:  iterable,    bins with which histograms are calculated in deg, default = -180° to 180° with 18° steps
    :param corr:  bool,        wether to correct for the source sky position and cosima's "RelativeY" polarization definition or not, default=False
    :param ergCut: couple (Emin, Emax) or None, energy range in which to perform polarization analysis, default=None(=all data available)
    :returns:     Polarigram instance
    """
    self.bins = bins
    self.theta = theta*np.pi/180
    self.phi = phi*np.pi/180
    self.PA = PA
    self.fits = []
    if type(data) == list:
      list.__init__(self, data)#ergCut not implemented. Nor is corr, PA, etc.
    elif type(data) == str:
      list.__init__(self, analyzetra(data, self.theta, self.phi, self.PA, ergCut))
      if corr:
        self.corr()
      self.behave()

  def cor(self):
    """
    Calculates the angle to correct for the source sky position and cosima's "RelativeY" polarization definition
    :returns: float, angle ni deg
    Warning : That's actually minus the correction angle (so that the correction uses a + instead of a - ...)
    """
    return np.arctan(np.cos(self.theta)*np.tan(self.phi))*180/np.pi+self.PA

  def behave(self, width=360):
    """
    Make angles be between the beginning of the first bin and the beginning of the first bin plus the width parameter
    Calculi are made in-place
    :param width: float, width of the polarigram in deg, default=360, SHOULD BE 360
    """
    for i in range(len(self)):
      self[i] = self[i] % width + self.bins[0]

  def corr(self):
    """
    Corrects the angles from the source sky position and cosima's "RelativeY" polarization definition
    """
    cor = self.cor()
    for i in range(len(self)):
      self[i] += cor
    self.behave()

  def anticorr(self):
    """
    Undo the corr operation
    """
    cor = self.cor()
    for i in range(len(self)):
      self[i] -= cor
    self.behave()

  def fit(self, unpoldata=None):
    """
    Fits first a modulation function and then a constant function to the polarigram
    :param unpoldata: Polarigram or None, Polarigram used for geometry correction, default=None
    """
    x = .5* (self.bins[1:] + self.bins[:-1])
    binw = self.bins[1:] - self.bins[:-1]
    p = np.histogram(self, self.bins)[0] / binw
    if unpoldata != None:
      unpol = np.histogram(unpoldata, self.bins)[0] / binw
      p /= unpol
    self.fits.append(Fit(func, x, p, "modulation"))
    self.fits.append(Fit(lambda x,a:a*x/x ,  x ,  p, "constant"))

  def clf(self):
    """
    Clears the fit list
    """
    self.fits = []

  def show(self, unpoldata=None, fit=False, disp=True, plot=True, plotfit=[-2], show=True, ret=True):
    """
    Plots and show a polarigram, and also does all the statistical analysis (indev)
    :param unpoldata: Polarigram,  unpolarised data to correct for geometrical effects
    :param fit:       bool,        whether or not to fit the polarigram,                  default=False
    :param disp:      bool,        whether or not to print fit results,                   default=True
    :param plot:      bool,        whether or not to plot the polarigram and fit results, default=True
    :param plotfit:   list of int, which fit(s) to plot (None is none),                   default=[-2]
    :param show:      bool,        whether or not to show fit results,                    default=True
    :returns:         couple of np.ndarray or None
    """
    x = .5* (self.bins[1:] + self.bins[:-1])
    binw = self.bins[1:] - self.bins[:-1]
    p = np.histogram(self, self.bins)[0] / binw
    ylabel = "Number of counts (per degree)"
    if unpoldata != None:
      unpol = np.histogram(unpoldata, self.bins)[0] / binw
      p /= unpol
      ylabel = "Corrected number of count"
    if fit:
      self.fit(unpoldata)
      #Fit a cosine
      #self.fits.append(Fit(func, x, p, "modulation"))
      #popt, pcov = curve_fit(func, x, p)
      #Fit a constant
      #self.fits.append(Fit(lambda x,a:a ,  x ,  p, "constant"))
      #popt2, pcov2 = curve_fit(lambda x,a:a ,  x ,  p)
    #if disp and len(self.fits) > 1:
    #  self.disp_stat()
    if plot:
      plt.step(x, p, "g", where="mid")
      if plotfit != None:
        xfit = np.arange(self.bins[0]-binw[0], self.bins[-1]+binw[-1], 1)
        for i in plotfit:
          if disp: self.fits[i].disp()
          plt.plot(xfit, self.fits[i].f(xfit, *self.fits[i].popt), "r--")
      plt.xlabel("Azimuthal scatter angle (degree)")
      plt.ylabel(ylabel)
      if show: plt.show()
    if ret:
      return p



############ MULTIPLE TRA FILES ANALYSIS ############

def fname2decra(fname, polmark="inc1"):
  """
  Infers dec and RA from file name
  :param fname: *.tra or *.tra.gz filename
  :param polmark: str that identifies polarized files, default='inc1'
  :returns: dec, RA, polarized
  """
  data = fname.split("_")
  return float(data[2]), float(".".join(data[3].split(".")[:2])), polmark in data[3]

class Polsim:
  """
  Container for the main results of a polarization simulation (mu100 and count rate)
  Contains the data of a GRB at a single position seen by all satellites
  :member nsat: list of int, satellites that saw the GRB
  :member duration: float, duration of the simulation in s., optional
  :member dec: list of float, declination of the simulations (0 = north pole)
  :member ra: list of float, right ascension of the simulations
  :member p: list of Polarigram, polarized simulations
  :member np: list of Polarigram, unpolarized simulations
  """
  def __init__(self, prefix, infos, grbname="", nsim=0, ergCut=None, duration=1, corr=False):
    """
    Uses Polarigram to calculate the modulation factor mu100 and the count rate of the source for both a satellite or a constellation
    :param prefix: str, path and prefix to the data file names
    :param grbname: str, GRBYYMMDDfff as writen in the file names
    :param nsim: int, sim number to consider
    :param infos: dict from par file containing satellite orientation information, see function trafile.parFile
    :param ergCut: couple (Emin, Emax) or None, passed to Polarigram
    :param duration: duration of the simulation, default=1 SHOULD NEVER BE 0
    """
    if prefix.endswith(".h5"):
      hf = h5py.File(prefix, "r")
      self.nsat = hf.get('nsat')[()]
      self.duration = hf.get('duration')[()]
      self.dec = hf.get('dec')[()]
      self.ra = hf.get('ra')[()]
      self.p, self.np = [], []
      for i in range(len(self.nsat)):
        self.p.append(Polarigram( list(hf.get("polarized").get(str(i))[()]), *decra2tpPA(self.dec[i], self.ra[i], infos['satellites'][self.nsat[i]]), corr=False ))
        self.np.append(Polarigram( list(hf.get("unpolarized").get(str(i))[()]), *decra2tpPA(self.dec[i], self.ra[i], infos['satellites'][self.nsat[i]]), corr=False ))
      hf.close()
    else:
      self.duration = duration
      self.p, self.np = [], []
      self.dec, self.ra, self.nsat = [], [], []
      for i in range(len(infos['satellites'])):
        #print("fichiers qui seront charges : ", "{}_{}-sat{}-{:04d}_*".format(prefix, grbname, i, nsim))
        ls = "ls {}_{}-sat{}-{:04d}_*".format(prefix, grbname, i, nsim)
        flist = subprocess.getoutput(ls).split("\n")
        if len(flist) == 2:
          for f in flist:
            dec, ra, pol = fname2decra(f)
            if pol:
              self.p.append(Polarigram(f, *decra2tpPA(dec, ra, infos['satellites'][i]), corr=corr, ergCut=ergCut))
              #p[-1].corr() if corr=False in the line above (might be quicker)
            else:
              self.np.append(Polarigram(f, *decra2tpPA(dec, ra, infos['satellites'][i]), corr=corr, ergCut=ergCut))
          self.nsat.append(i)
          self.dec.append(dec)
          self.ra.append(ra)

  def corr(self):
    """
    """
    for e in self.p:
      e.corr()
    for e in self.np:
      e.corr()

  def anticorr(self):
    """
    """
    for e in self.p:
      e.anticorr()
    for e in self.np:
      e.anticorr()

  def imgCompton(self, const, b, SBRmin, Nc, t90):
    """
    Checks whether this simulation can make a Compton image. Condition is S/B > SBRmin and S > Nc
    with S = S_sim / T_sim * T90; B = b*T90
    :param const: constellation
    :param b: backgorund rate
    :param SBRmin: minimum signal to background
    :param Nc: minimum number of Compton events
    :returns: bool
    """
    intersect = list(set(self.nsat).intersection(const))
    n = 0; nsat = len(intersect)
    for i in intersect:
      n += len(self.np[list(self.nsat).index(i)])
    return int(n/self.duration/b/nsat > SBRmin)+2*int(n*t90/self.duration > Nc)

  def analyze(self, const, bins=np.arange(-180, 181, 18), show=False):
    """
    Returns modulation factor mu100 and the source count rate
    :param const: list of int, constellation to consider (for single instrument, give list of len 1)
    :returns: number of satellites used, mu100, count rate (count number / simulation duration)
    """
    intersect = list(set(self.nsat).intersection(const))
    if len(intersect) < 1:
      return 0, 0, np.nan, 0
    #add polarigrams here
    pol = Polarigram([], 0, 0, 0, bins, corr=False)
    npol = Polarigram([], 0, 0, 0, bins, corr=False)
    for i in intersect:
      pol += self.p[list(self.nsat).index(i)]
      npol += self.np[list(self.nsat).index(i)]
    if show:
      for i in intersect:
        self.p[list(self.nsat).index(i)].show(self.np[list(self.nsat).index(i)], fit=True, ret=False)
    try:
      pol.fit(npol)
      if show: pol.show(npol, ret=False)
    except ValueError:
      return len(intersect), np.nan, np.nan, len(pol)/self.duration
    if pol.fits[-2].popt[1] < 0:
      return len(intersect), -pol.fits[-2].popt[1], np.mod(pol.fits[-2].popt[0]+90, 180), len(pol)/self.duration
    else:  
      return len(intersect), pol.fits[-2].popt[1], np.mod(pol.fits[-2].popt[0], 180), len(pol)/self.duration

  def write(self, fname):
    """
    Writes all object content to a *.h5 hdf5 file.
    :param fname: name of the file
    """
    hf = h5py.File(fname, "w")
    hf.create_dataset('nsat', data=self.nsat)
    hf.create_dataset('duration', data=self.duration)
    hf.create_dataset('dec', data=self.dec)
    hf.create_dataset('ra', data=self.ra)
    pol = hf.create_group("polarized")
    for i, e in enumerate(self.p):
      pol.create_dataset(str(i), data=e)
    npol = hf.create_group("unpolarized")
    for i, e in enumerate(self.np):
      npol.create_dataset(str(i), data=e)
    hf.close()


class Poltab:
  """
  :member namelist: list of GRB names
  :member nsim: number of simulation per GRB
  :member tab: table of simulations (first index = GRB, second index = nsim)
  """
  def __init__(self, prefix, namelist, nsim, infos, ergCut=None, duration=0):
    """
    Instanciate Poltab
    :param prefix: str, path and prefix to tra files or directory full of *.h5 files
    :param namelist: list of GRB names
    :param nsim: int, number of simulations
    :param infos: dict() from parFile
    :param ergCut: couple (Emin, Emax) or None, default=None
    :param duration: float, simulations duration, IF 0 DATA WILL BE READ FROM FILES, default=0
    """
    self.namelist = namelist
    self.nsim = nsim
    if duration == 0:#Read from directory full of .h5 files
      self.tab = [[Polsim("{}{}-{}.h5".format(prefix, name, j), infos) for j in range(nsim)] for name in LoadingBar(namelist)]
    else:
      self.tab = [[Polsim(prefix, infos, e, i, ergCut, duration) for i in range(nsim)] for e in LoadingBar(namelist)]

  def corr(self):
    """
    Align polarigrams in place
    """
    for e in self.tab:
      for f in e:
        f.corr()

  def anticorr(self):
    """
    Align polaigrams in place
    """
    for e in self.tab:
      for f in e:
        f.anticorr()

  def analyze(self, const):
    """
    Calculates mu100 and source count rate for the specified constellation
    :param const: list of int, constellation
    :returns: table of (nsat, mu100, source count rate)
    """
    return np.array([[self.tab[i][j].analyze(const) for j in range(self.nsim)] for i in LoadingBar(range(len(self.namelist)))])

  def imgCompton(self, grbdurations, const, b, Nc, SBRmin=10):
    """
    Computes the probabilities for each GRB to allow making a Compton image - see Polsim.imgCompton for more infos
    :param grbdurations: list of GRBs T90
    :param const: list of int, constellation to use
    :param b: background rate
    :param Nc: minimum number of Compton events to perform Compton imaging
    :param SBRmin: minimum signal to background ratio, default=10
    :returns: np.array
    """
    return np.array([[self.tab[i][j].imgCompton(const, b, SBRmin, Nc, grbdurations[i]) for j in range(self.nsim)] for i in range(len(self.namelist))])

  def write(self, dirname):
    """
    Writes all polsims in hdf5 *.h5 file in a directory
    :param dirname: name of existing directory
    """
    if not(dirname.endswith("/")): dirname+="/"
    for i, name in enumerate(LoadingBar(self.namelist)):
      for j in range(self.nsim):
        self.tab[i][j].write("{}{}-{}.h5".format(dirname, name, j))


def mdp99(data, grbdurations, brate):
  """
  data_const = Poltab.analyze(const)
  :param grbdurations: calatog of GRB's T90 in the same order as in Poltab's namelist
  :param brate: float, background rate
  """
  return np.array([[MDP(grbdurations[i]*sim[3], brate*grbdurations[i]*sim[0], sim[1], 4.29) if sim[0] else np.nan for sim in grb] for i, grb in enumerate(LoadingBar(data))])



############ PIGGYBACK TRA FILE ANALYSIS ############

def gauss(x, x0, sig, A):
  """
  1-D gaussian function
  :param x: scalar or array, position(s) at which evaluate the function
  :param x0: position of the center of the gaussian
  :param sig: sigma parameter of the gaussian
  :param A: Area of the gaussian
  :returns: scalar or array, value(s) of the gaussian function
  """
  return A/( sig*np.sqrt(2*np.pi) )*np.exp( -.5*((x-x0)/sig)**2 )

def makeSp(fname, bins=np.arange(0, 2000, 5)):
  with open(fname) as f:
    lines=f.read().split("\n")
  ergs = []
  for line in lines:
    if line.startswith("CE"): 
      ergs.append(float(line.split(" ")[1])+float(line.split(" ")[5]))
  hist, _ = np.histogram(ergs, bins)
  x = .5*(bins[1:]+bins[:-1])
  xmax = x[hist.argmax()]
  sig0 = .05*xmax
  popt, pcov = curve_fit(gauss, x, hist, p0=[xmax, sig0, np.sqrt(2*np.pi)*sig0*hist.max()])
  plt.plot(x, hist, "xb")
  plt.plot(x, gauss(x, *popt), "g--")
  plt.xlabel("Energy [keV]")
  plt.ylabel("Number of hits")
  plt.show()
  return popt, pcov

def interpolate1D(xa, ya, xb, yb, x, t="LIN"):
  """
  """
  if t=="LIN":
    return (yb-ya)/(xb-xa)*(x-xa)+ya



class MEGAdata:
  """
  To contain and plot data from MEGAlib-formated data files
  """

  def __init__(self, fname, dimension=1):
    """
    Load a MEGAlib-formated data file
    :param fname: str, file name
    :param dimension: expected dimension
    """
    self.dimension = dimension
    with open(fname) as f:
      lines = f.read().split("\n")
    if self.dimension == 1:
      self.x, self.y = [], []
      for line in lines:
        if line[:2] in ["EN", "AP", "XA", "YA", "XB", "YB", "PA", "TA", "EA"]: break
        elif line.startswith("IP"): #interpolation mode
          self.ipx = line[3:6]
          self.ipy = line[6:9]
        elif line.startswith("DP"): #data point
          t = list(filter(('').__ne__, line.split(" ")))
          self.x.append(float(t[1]))
          self.y.append(float(t[2]))

  def __len__(self):
    """
    """
    if self.dimension == 1:
      if len(self.x) == len(self.y):
        return len(self.x)
      else:
        return len(self.x), len(self.y)

  def F(self, *args):
    """
    """
    if self.dimesion==1:
      pass

  def plot(self, **kwargs):
    """
    """
    if self.dimension == 1:
      plt.plot(self.x, self.y, **kwargs)
      plt.show()

